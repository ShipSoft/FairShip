<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FairShip: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FairShip
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_field_2README.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">README</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Magnetic fields for the FairShip simulation use the Geant4 VMC ("geant4_vmc") interface, which associates ROOT <a href="https://root.cern.ch/doc/master/classTVirtualMagField.html">TVirtualMagField</a> objects to Geant4 <a href="https://www-zeuthen.desy.de/geant4/geant4.9.3.b01/classG4MagneticField.html">G4MagneticField</a> ones via the macro command</p>
<div class="fragment"><div class="line">/mcDet/setIsLocalMagField true</div>
</div><!-- fragment --><p>which is called in the <a href="../gconfig/g4config.in">g4config.in</a> input file.</p>
<p>Most of the required TVirtualMagField objects are already created in the C++ source code where the geometry volumes are defined. The <a href="ShipFieldMaker.h">ShipFieldMaker</a> class can be used to create new, extra fields, or replace already existing ones, using either an input control text file or by calling various definition functions, where we can set global and/or local fields for specific volumes. The VMC uses cm for distances and kGauss (0.1 Tesla) for magnetic fields. Here, we use the same cm unit for lengths, but use Tesla for magnetic fields, which the <a class="el" href="classShipFieldMaker.html" title="Creates various magnetic fields and assigns them to geometry regions.">ShipFieldMaker</a> class converts to kGauss units when passed to the VMC.</p>
<p>The function</p>
<div class="fragment"><div class="line">TVirtuaMagField::Field(const Double_t* pos, Double_t* B)</div>
</div><!-- fragment --><p>that is implemented in the various derived field classes finds the magnetic field components and stores them in the array B given the global, not local, coordinate position pos; note that Geant4 can only use global positional coordinates for finding fields.</p>
<p>The script <a href="../macro/run_simScript.py">run_simScript.py</a> calls the addVMCFields() function defined in <a href="../python/geomGeant4.py">geomGeant4.py</a>, which creates a <a class="el" href="classShipFieldMaker.html" title="Creates various magnetic fields and assigns them to geometry regions.">ShipFieldMaker</a> object. This then reads a control file, or calls definition functions, that specifies what magnetic fields are required for the simulation. Note that B fields (TVirtualMagFields) already defined in the geometry C++ source code do not need to be added again via either the input file or with definition functions. The <a class="el" href="classShipFieldMaker.html" title="Creates various magnetic fields and assigns them to geometry regions.">ShipFieldMaker</a>, which inherits from <a href="https://github.com/vmc-project/geant4_vmc/blob/master/source/geometry/include/TG4VUserPostDetConstruction.h">TG4VUserPostDetConstruction</a>, is then passed onto the ROOT/Geant4 geometry <a href="https://github.com/vmc-project/geant4_vmc/blob/master/source/geometry/include/TG4GeometryManager.h">manager</a> and the VMC fields are updated via the overridden <a class="el" href="classShipFieldMaker.html#abf937564fc0ec2b7acc56f01d0865b59" title="Set-up all local and regional fields and assign them to volumes.">ShipFieldMaker::Construct()</a> function.</p>
<p>The run script can also generate plots of the magnitude of the magnetic field in the z-x, z-y and/or x-y plane using the plotField function in <a href="ShipFieldMaker.h">ShipFieldMaker</a>. The location of the control file, and any field maps that it uses, must be specified relative to the VMCWORKDIR directory.</p>
<p>The structure of the control file, such as <a href="ExampleBFieldSetup.txt">ExampleBFieldSetup.txt</a>, uses specific keywords to denote what each line represents:</p>
<div class="fragment"><div class="line">0) Comment lines start with the # symbol</div>
<div class="line">1) &quot;FieldMap&quot; for using field maps to represent the magnetic field</div>
<div class="line">2) &quot;SymFieldMap&quot; for using field maps with x-y quadrant symmetry</div>
<div class="line">3) &quot;CopyMap&quot; for copying a previously defined field map to another location (saving memory)</div>
<div class="line">4) &quot;Uniform&quot; for creating a uniform magnetic field (no coordinate limits)</div>
<div class="line">5) &quot;Constant&quot; for creating a uniform magnetic field with coordinate boundary limits</div>
<div class="line">6) &quot;Bell&quot; for creating the Bell shaped magnetic field distribution</div>
<div class="line">7) &quot;Composite&quot; for combining two or more field types/sources</div>
<div class="line">8) &quot;Global&quot; for setting which (single or composite) field is the global one</div>
<div class="line">9) &quot;Region&quot; for setting a local field to a specific volume, including the global field</div>
<div class="line">10) &quot;Local&quot; for only setting a local field to a specific volume, ignoring the global field</div>
</div><!-- fragment --><p>Alternatively, the above field types can be defined using various "defineX()" functions in <a href="ShipFieldMaker.h">ShipFieldMaker</a>, where parameters are passed as function arguments.</p>
<p>The syntax for each of the above options are as follows, where the control file arguments are shown first then the alternative definition functions:</p>
<p>1) <a href="ShipBFieldMap.h">FieldMap</a></p>
<div class="fragment"><div class="line">FieldMap Name MapFileName [x0 y0 z0] [phi theta psi]</div>
</div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line">defineFieldMap(Name, MapFileName, TVector3(x0, y0, z0), TVector3(phi, theta, psi));</div>
</div><!-- fragment --><p>where Name is the descriptive name or title of the field, MapFileName is the location of the ROOT file containing the field map data (relative to the VMCWORKDIR directory), x0, y0, z0 are the offset coordinates in cm, and phi, theta and psi are the Euler rotation angles in degrees about the z axis, the new x axis, and then the new z axis, in that order. The offsets and angles are optional parameters (denoted by the square brackets); default values are all set to zero. Note that offsets still need to be provided (can be set to zero) if angles are required.</p>
<p>A field map that is local to a particular volume is assumed to be centred and aligned along the local symmetry axes. For example, if there is a collection of identical magnets that all use the same field map, but the magnets have different global positions and orientations in the geometry, then we only need to define one field map, with zero offsets and angles, using a binning that ensures that the map is centred and aligned along the local coordinate axes of the magnet shape. The code will then create lightweight copies of the field map (reusing the binning data) for each of the magnets, displaced and rotated to match their global positions and orientations. This occurs when the map name is used in either the Local or Region field-volume definitions described below. If the field map definition contains non-zero offsets and angles (i.e. if the original data needs displacement or rotation corrections) then these would be applied first before the individual volume transformations. A global field map will not apply local volume transformations, only those offsets and angles that is part of its definition.</p>
<p>The field is calculated by the <a href="ShipBFieldMap.h">ShipBFieldMap</a> class using trilinear interpolation based on the binned map data, which is essentially a 3d histogram.</p>
<p>The structure of the field map ROOT data file is as follows. It should contain two TTrees, one called Range which specifies the coordinate limits and bin sizes (in cm) using the following floating-point precision variables:</p>
<div class="fragment"><div class="line">xMin, xMax, dx, yMin, yMax, dy, zMin, zMax, dz</div>
</div><!-- fragment --><p>and another one called Data which stores the floating-point precision B field components (T)</p>
<div class="fragment"><div class="line">Bx, By, Bz</div>
</div><!-- fragment --><p>assuming the position binning order (iX*Ny + iY)*Nz + iZ, where (iX,iY,iZ) is the equivalent bin for coordinate (x,y,z), and Ny and Nz are the number of y and z bins, respectively.</p>
<p>All variables are stored with floating-point (not double) precision to save both disk space as well as memory consumption within the FairShip code.</p>
<p>The script <a href="convertMap.py">convertMap.py</a> can be used to convert a general (ascii) field map data file into the ROOT file format for FairShip use. Alternatively, the scripts <a href="convertMisisMap.py">convertMisisMap.py</a> and <a href="convertRALMap.py">convertRALMap.py</a> can be used for converting field maps generated from MISIS or RAL (VectorFields/Opera software output) engineering work, respectively.</p>
<p>2) <a href="ShipBFieldMap.h">SymFieldMap</a>: x-y quadrant symmetric field map</p>
<div class="fragment"><div class="line">SymFieldMap Name MapFileName [x0 y0 z0] [phi theta psi]</div>
</div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line">defineFieldMap(Name, MapFileName, TVector3(x0, y0, z0), TVector3(phi, theta, psi), useSymmetry);</div>
</div><!-- fragment --><p>where useSymmetry is a boolean that needs to be set to kTRUE (default = kFALSE).</p>
<p>This reuses the <a href="ShipBFieldMap.h">ShipBFieldMap</a> class to define a field map where we have x-y quadrant symmetry: Bx is antisymmetric in x and y, By is symmetric in x and y, while no symmetry is assumed for Bz. This implies that Bx changes sign whenever x &lt; 0 or y &lt; 0; note that Bx remains unchanged when we have both x &lt; 0 and y &lt; 0. We only need to store the field components for the positive x and y quadrant coordinates in the ROOT file defined by the MapFileName string (relative to the VMCWORKDIR directory), requiring only roughly 25% of the memory compared to a full field map. The parameters x0, y0, z0 are the offset coordinates in cm, and phi, theta and psi are the Euler rotation angles in degrees about the z axis, the new x axis, and then the new z axis, in that order. The offsets and angles are optional parameters (denoted by the square brackets) with default values equal to zero; offsets still need to be provided (can be set to zero) if angles are required.</p>
<p>3) CopyMap</p>
<div class="fragment"><div class="line">CopyMap Name MapToCopy x0 y0 z0 [phi theta psi]</div>
</div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line">defineFieldMapCopy(Name, MapToCopy, TVector3(x0, y0, z0), TVector3(phi, theta, psi));</div>
</div><!-- fragment --><p>where Name is the new name or title of the copied map, MapToCopy is the name of the (previously defined) map to be copied, with the new coordinate offsets specified by the values x0, y0 and z0 (cm), as well as the optional Euler rotation angles phi, theta and psi (degrees), corresponding to rotations about the z, new x and new z axis, in that order. Note that this will reuse the field map data already stored in memory.</p>
<p>4) <a href="https://root.cern.ch/doc/master/classTGeoUniformMagField.html">Uniform</a></p>
<div class="fragment"><div class="line">Uniform Name Bx By Bz</div>
</div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line">defineUniform(Name, TVector3(Bx, By, Bz));</div>
</div><!-- fragment --><p>where Bx, By and Bz are the components of the uniform field (in Tesla), valid for any x,y,z coordinate value.</p>
<p>5) <a href="ShipConstField.h">Constant</a></p>
<div class="fragment"><div class="line">Constant Name xMin xMax yMin yMax zMin zMax Bx By Bz</div>
</div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line">defineConstant(Name, TVector2(xMin, xMax), TVector2(yMin, yMax), TVector2(zMin, zMax), TVector3(Bx, By, Bz));</div>
</div><!-- fragment --><p>where xMin, xMax are the global coordinate limits along the x axis (in cm), similarly for the y and z axes, and Bx, By and Bz are the components of the uniform field in Tesla.</p>
<p>6) <a href="ShipBellField.h">Bell</a></p>
<div class="fragment"><div class="line">Bell Name BPeak zMiddle orientInt tubeRad [xy z L]</div>
</div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line">defineBell(Name, BPeak, zMiddle, orientInt, tubeR, xy, z, L);</div>
</div><!-- fragment --><p>where Name is the name or title of the field, BPeak is the peak of the magnetic field (in Tesla), zMiddle is the global z location of the centre of the field (cm), orientInt is an integer to specify if the field is aligned either along the x (2) or y (1) axes (Bz = 0 always), and tubeRad is the radius of the tube (cm) inside the region which specifies the extent of the field (for Bx). The parameters xy, z and L are optional "target" settings; xy is the target radius region (cm), z is its starting global position (cm) while L specifies the length (cm).</p>
<p>7) <a href="ShipCompField.h">Composite</a>: linear combination of fields</p>
<div class="fragment"><div class="line">Composite theName Name1 ... NameN</div>
</div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line">defineComposite(theName, Name1, Name2, Name3 = &quot;&quot;, Name4 = &quot;&quot;);</div>
</div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line">defineComposite(theName, std_vector_of_field_names);</div>
</div><!-- fragment --><p>where theName is the name of the composite field, comprising of the fields named Name1 up to NameN. There are two versions of the definition functions; the first can accept up to four field names (at least two names are required), while the other can accept a general vector of TString names.</p>
<p>8) Global</p>
<div class="fragment"><div class="line">Global Name1 .. NameN</div>
</div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line">defineGlobalField(Name1, Name2 = &quot;&quot;, Name3 = &quot;&quot;, Name4 = &quot;&quot;);</div>
</div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line">defineGlobalField(std_vector_of_field_names);</div>
</div><!-- fragment --><p>where Name1 to NameN are the names of the fields that are combined to represent the "Global" field for the whole geometry. There are two versions of the definition functions; the first can accept up to four field names (at least one name is required), while the other can accept a general vector of TString names. Note that there can only be one global field in the VMC by definition, and any previously defined global field is overridden.</p>
<p>9) Region: linear combination of local and global fields</p>
<div class="fragment"><div class="line">Region VolName FieldName [FieldMapScaleFactor]</div>
</div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line">defineRegionField(VolName, FieldName, FieldMapScaleFactor = 1.0);</div>
</div><!-- fragment --><p>where VolName is the name of the TGeo volume, FieldName is the name of the local field that should be assigned to this volume and FieldMapScaleFactor is an optional scaling number that can be used to adjust the (maximum) magnitude of any local field map (not other field types). Any particle inside this volume will experience the superposition of the (scaled) local field with the global one.</p>
<p>10) Local: global fields are ignored</p>
<div class="fragment"><div class="line">Local VolName FieldName [FieldMapScaleFactor]</div>
</div><!-- fragment --><p>where VolName is the name of the TGeo volume, FieldName is the name of the local field that should be assigned to this volume and FieldMapScaleFactor is an optional scaling number that can be used to adjust the (maximum) magnitude of any local field map (not other field types). This will not include the global field, i.e. any particle inside this volume will only see the local one.</p>
<p>As mentioned earlier, magnetic fields for local volumes are enabled for the VMC with the setting "/mcDet/setIsLocalMagField true" in the <a href="../gconfig/g4config.in">g4config.in</a> file. Extra options for B field tracking (stepper/chord finders..), such as those mentioned here</p>
<p><a href="https://root.cern.ch/magnetic-field">https://root.cern.ch/magnetic-field</a></p>
<p>should be added to the (end of) the g4config.in file.</p>
<p>Other magnetic field classes can use the above interface provided they inherit from <a href="https://root.cern.ch/doc/master/classTVirtualMagField.html">TVirtualMagField</a>, implement the TVirtualMagField::Field() virtual function, and are recognised by the <a href="ShipFieldMaker.h">ShipFieldMaker</a> class by appropriate "defineX()" functions that can also be called by the readInputFile() function via unique keyword-formatted lines within the configuration text file. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
